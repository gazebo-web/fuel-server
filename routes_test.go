package main

import (
	"fmt"
	"github.com/gazebo-web/fuel-server/globals"
	"github.com/gazebo-web/gz-go/v7"
	gztest "github.com/gazebo-web/gz-go/v7/testhelpers"
	"github.com/jinzhu/gorm"
	"github.com/stretchr/testify/assert"

	"net/http"
	"testing"
)

// Generic Routes tests

var routesAPI2 = gz.Routes{
	// Test api 2.0
	gz.Route{
		"Test api 2.0",
		"example route",
		"/testapi",
		gz.AuthHeadersOptional,
		gz.Methods{
			gz.Method{
				"GET",
				"Test api",
				gz.FormatHandlers{
					gz.FormatHandler{"", gz.Handler(handlerAPI2)},
				},
			},
		},
		gz.SecureMethods{},
	},
}

func handlerAPI2(tx *gorm.DB, w http.ResponseWriter, r *http.Request) *gz.ErrMsg {
	fmt.Println("TestApi2")
	return nil
}

// Just invokes an invalid route
func TestInvalidRoute(t *testing.T) {
	// General test setup
	setup()
	gztest.InvalidRouteTestHelper(t)
}

// Test the autogenerated OPTIONS urls
func TestOptions(t *testing.T) {
	// General test setup
	setup()

	var names []string
	var uris []string
	for _, r := range routes {
		names = append(names, r.Name)
		prefixedURI := "/1.0" + r.URI
		uris = append(uris, prefixedURI)
	}
	gztest.OptionsTestHelper(uris, names, t)
}

// Just invokes an invalid route
func TestSupportForMultipleAPIVersions(t *testing.T) {
	origRouter := globals.Server.Router
	defer globals.Server.SetRouter(origRouter)

	// General test setup
	setup()
	v1prefix := "/1.0"
	v2prefix := "/2.0"
	s := globals.Server
	mainRouter := gz.NewRouter()
	// Example with 2 simultaneous APIs
	r := mainRouter.PathPrefix(v1prefix).Subrouter()
	s.ConfigureRouterWithRoutes(v1prefix, r, routes)
	// Now create a sub router , enabled with /2.0/
	sub := mainRouter.PathPrefix(v2prefix).Subrouter()
	s.ConfigureRouterWithRoutes(v2prefix, sub, routesAPI2)
	s.SetRouter(mainRouter)

	// Set the new test router
	gztest.SetupTest(mainRouter)

	// Test the OPTIONS routes with the 2 apis
	var names []string
	var uris []string
	for _, r := range routes {
		names = append(names, r.Name)
		prefixedURI := v1prefix + r.URI
		uris = append(uris, prefixedURI)
	}
	for _, r := range routesAPI2 {
		names = append(names, r.Name)
		prefixedURI := v2prefix + r.URI
		uris = append(uris, prefixedURI)
	}
	gztest.OptionsTestHelper(uris, names, t)
}

// Tests that the sqlTx error message has not changed.
// NOTE: We need this test
// because in the server code we compare against the error message to
// detect is the underlying error is a TX error from the sql driver.
func TestSqlTxError(t *testing.T) {
	tx := globals.Server.Db.Begin()
	assert.NoError(t, tx.Rollback().Error)
	// should NOT fail on subsequent calls to rollback
	assert.NoError(t, tx.Rollback().Error)
	assert.False(t, gz.IsSQLTxError(tx.Error))
	// should fail on subsequent calls to commit
	assert.Error(t, tx.Commit().Error)
	assert.True(t, gz.IsSQLTxError(tx.Error))

	tx = globals.Server.Db.Begin()
	assert.NoError(t, tx.Commit().Error)
	// should NOT fail on subsequent calls to rollback
	assert.NoError(t, tx.Rollback().Error)
	assert.False(t, gz.IsSQLTxError(tx.Error))
	// should fail on subsequent calls to rollback
	assert.Error(t, tx.Commit().Error)
	assert.True(t, gz.IsSQLTxError(tx.Error))

	tx = globals.Server.Db.Begin()
	assert.Error(t, tx.Begin().Error)
}
